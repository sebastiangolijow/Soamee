{"ast":null,"code":"module.exports = apiServiceFactory;\n\nconst rateLimiter = require('./rate-limiter');\n\nconst debugLogger = require('./debug-logger');\n\nconst axios = require('axios');\n\nfunction apiServiceFactory(opts) {\n  var debugInstance;\n  var instance;\n  var baseRequest = {\n    method: 'get',\n    headers: opts.headers,\n    timeout: opts.timeout\n  };\n  var baseRequestParams = {\n    format: 'json',\n    apiKey: opts.key\n  };\n\n  function apiService(requestOpts, callback, attempts) {\n    if (!attempts) attempts = 0;\n    var request = Object.assign({}, baseRequest, requestOpts);\n    request.params = Object.assign({}, baseRequestParams, requestOpts.params);\n    return runAxios(opts, request).then(result => {\n      if (callback) callback(null, result.data);\n      return result.data;\n    }).catch(error => {\n      attempts++;\n\n      if (attempts > opts.maxRetries) {\n        return finishWithError(error, request.params.format, callback);\n      }\n\n      if (error.response && error.response.status > 400 && error.response.status !== 404) {\n        return waitABit(opts.retryInterval).then(() => apiService(requestOpts, callback, attempts));\n      }\n\n      if (error.code) {\n        return waitABit(opts.retryInterval).then(() => apiService(requestOpts, callback, attempts));\n      }\n\n      return finishWithError(error, request.params.format, callback);\n    });\n  }\n\n  function finishWithError(error, requestFormat, callback) {\n    const wrappingError = new Error('Exceeded max retries');\n    wrappingError.cause = error;\n    const response = error.response;\n\n    if (response) {\n      wrappingError.headers = response.headers;\n      wrappingError.status = response.status;\n\n      if (response.data.constructor.name === 'IncomingMessage') {\n        return getBodyFromStream(response.data).then(body => {\n          wrappingError.body = requestFormat === 'json' ? JSON.parse(body) : body;\n          return wrappingError;\n        }).catch(error => {\n          wrappingError.errorHandlingError = error;\n          return wrappingError;\n        }).then(wrappingError => {\n          if (callback) callback(wrappingError);\n          throw wrappingError;\n        });\n      } else {\n        wrappingError.body = response.data;\n      }\n    }\n\n    if (callback) {\n      callback(wrappingError);\n    } else {\n      return Promise.reject(wrappingError);\n    }\n  }\n\n  function getBodyFromStream(s) {\n    return new Promise((resolve, reject) => {\n      let body = '';\n      s.on('readable', () => {\n        const read = s.read();\n        if (read) body += read;\n      });\n      s.on('error', error => {\n        reject(error);\n      });\n      s.on('end', () => {\n        resolve(body);\n      });\n    });\n  }\n\n  function waitABit(ms) {\n    return new Promise(resolve => {\n      setTimeout(() => resolve(true), ms);\n    });\n  }\n\n  function runAxios(opts, data) {\n    if (opts.debug) {\n      if (!debugInstance) {\n        debugInstance = axios.create();\n        rateLimiter.rateLimiter(debugInstance, opts.requestsPerSecond);\n        debugLogger(debugInstance, opts.debug);\n      }\n\n      return debugInstance(data);\n    } else {\n      if (!instance) {\n        instance = axios.create();\n        rateLimiter.rateLimiter(instance, opts.requestsPerSecond);\n      }\n\n      return instance(data);\n    }\n  }\n\n  return apiService;\n}","map":{"version":3,"sources":["C:/Users/sebas/Desktop/folders/Jobs/Elaastacloud/client/node_modules/bestbuy/lib/api.service.js"],"names":["module","exports","apiServiceFactory","rateLimiter","require","debugLogger","axios","opts","debugInstance","instance","baseRequest","method","headers","timeout","baseRequestParams","format","apiKey","key","apiService","requestOpts","callback","attempts","request","Object","assign","params","runAxios","then","result","data","catch","error","maxRetries","finishWithError","response","status","waitABit","retryInterval","code","requestFormat","wrappingError","Error","cause","constructor","name","getBodyFromStream","body","JSON","parse","errorHandlingError","Promise","reject","s","resolve","on","read","ms","setTimeout","debug","create","requestsPerSecond"],"mappings":"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","sourcesContent":["module.exports = apiServiceFactory;\n\nconst rateLimiter = require('./rate-limiter');\nconst debugLogger = require('./debug-logger');\n\nconst axios = require('axios');\n\nfunction apiServiceFactory (opts) {\n  var debugInstance;\n  var instance;\n\n  var baseRequest = {\n    method: 'get',\n    headers: opts.headers,\n    timeout: opts.timeout\n  };\n  var baseRequestParams = { format: 'json', apiKey: opts.key };\n\n  function apiService (requestOpts, callback, attempts) {\n    if (!attempts) attempts = 0;\n    var request = Object.assign({}, baseRequest, requestOpts);\n    request.params = Object.assign({}, baseRequestParams, requestOpts.params);\n\n    return runAxios(opts, request)\n      .then(result => {\n        if (callback) callback(null, result.data);\n        return result.data;\n      })\n      .catch(error => {\n        attempts++;\n        if (attempts > opts.maxRetries) {\n          return finishWithError(error, request.params.format, callback);\n        }\n\n        if (error.response && error.response.status > 400 && error.response.status !== 404) {\n          return waitABit(opts.retryInterval).then(() => apiService(requestOpts, callback, attempts));\n        }\n\n        if (error.code) {\n          return waitABit(opts.retryInterval).then(() => apiService(requestOpts, callback, attempts));\n        }\n\n        return finishWithError(error, request.params.format, callback);\n      });\n  }\n\n  function finishWithError (error, requestFormat, callback) {\n    const wrappingError = new Error('Exceeded max retries');\n    wrappingError.cause = error;\n    const response = error.response;\n    if (response) {\n      wrappingError.headers = response.headers;\n      wrappingError.status = response.status;\n      if (response.data.constructor.name === 'IncomingMessage') {\n        return getBodyFromStream(response.data)\n          .then(body => {\n            wrappingError.body = requestFormat === 'json' ? JSON.parse(body) : body;\n            return wrappingError;\n          })\n          .catch(error => {\n            wrappingError.errorHandlingError = error;\n            return wrappingError;\n          })\n          .then(wrappingError => {\n            if (callback) callback(wrappingError);\n            throw wrappingError;\n          });\n      } else {\n        wrappingError.body = response.data;\n      }\n    }\n    if (callback) {\n      callback(wrappingError);\n    } else {\n      return Promise.reject(wrappingError);\n    }\n  }\n\n  function getBodyFromStream (s) {\n    return new Promise((resolve, reject) => {\n      let body = '';\n      s.on('readable', () => {\n        const read = s.read();\n        if (read) body += read;\n      });\n      s.on('error', error => {\n        reject(error);\n      });\n      s.on('end', () => {\n        resolve(body);\n      });\n    });\n  }\n\n  function waitABit (ms) {\n    return new Promise(resolve => {\n      setTimeout(() => resolve(true), ms);\n    });\n  }\n\n  function runAxios (opts, data) {\n    if (opts.debug) {\n      if (!debugInstance) {\n        debugInstance = axios.create();\n        rateLimiter.rateLimiter(debugInstance, opts.requestsPerSecond);\n        debugLogger(debugInstance, opts.debug);\n      }\n      return debugInstance(data);\n    } else {\n      if (!instance) {\n        instance = axios.create();\n        rateLimiter.rateLimiter(instance, opts.requestsPerSecond);\n      }\n      return instance(data);\n    }\n  }\n\n  return apiService;\n}\n"]},"metadata":{},"sourceType":"script"}